/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef sfm_TYPES_H
#define sfm_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace vision { namespace sfm { namespace gen {

struct RollingShutter {
  enum type {
    HORIZONTAL = 1,
    VERTICAL = 2
  };
};

extern const std::map<int, const char*> _RollingShutter_VALUES_TO_NAMES;

class Observation;

class Track;

class ObservationRef;

class Frame;

class Session;

typedef struct _Observation__isset {
  _Observation__isset() : x(false), y(false), descriptor(false), color(false), matches(false), track(false) {}
  bool x :1;
  bool y :1;
  bool descriptor :1;
  bool color :1;
  bool matches :1;
  bool track :1;
} _Observation__isset;

class Observation {
 public:

  Observation(const Observation&);
  Observation& operator=(const Observation&);
  Observation() : x(0), y(0), descriptor(), color(), track(0) {
  }

  virtual ~Observation() throw();
  double x;
  double y;
  std::string descriptor;
  std::string color;
  std::vector<ObservationRef>  matches;
  int32_t track;

  _Observation__isset __isset;

  void __set_x(const double val);

  void __set_y(const double val);

  void __set_descriptor(const std::string& val);

  void __set_color(const std::string& val);

  void __set_matches(const std::vector<ObservationRef> & val);

  void __set_track(const int32_t val);

  bool operator == (const Observation & rhs) const
  {
    if (!(x == rhs.x))
      return false;
    if (!(y == rhs.y))
      return false;
    if (__isset.descriptor != rhs.__isset.descriptor)
      return false;
    else if (__isset.descriptor && !(descriptor == rhs.descriptor))
      return false;
    if (__isset.color != rhs.__isset.color)
      return false;
    else if (__isset.color && !(color == rhs.color))
      return false;
    if (__isset.matches != rhs.__isset.matches)
      return false;
    else if (__isset.matches && !(matches == rhs.matches))
      return false;
    if (__isset.track != rhs.__isset.track)
      return false;
    else if (__isset.track && !(track == rhs.track))
      return false;
    return true;
  }
  bool operator != (const Observation &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Observation & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Observation &a, Observation &b);

inline std::ostream& operator<<(std::ostream& out, const Observation& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Track__isset {
  _Track__isset() : obs(false), pt(false), color(false), valid(true) {}
  bool obs :1;
  bool pt :1;
  bool color :1;
  bool valid :1;
} _Track__isset;

class Track {
 public:

  Track(const Track&);
  Track& operator=(const Track&);
  Track() : color(), valid(false) {
  }

  virtual ~Track() throw();
  std::vector<ObservationRef>  obs;
  std::vector<double>  pt;
  std::string color;
  bool valid;

  _Track__isset __isset;

  void __set_obs(const std::vector<ObservationRef> & val);

  void __set_pt(const std::vector<double> & val);

  void __set_color(const std::string& val);

  void __set_valid(const bool val);

  bool operator == (const Track & rhs) const
  {
    if (!(obs == rhs.obs))
      return false;
    if (__isset.pt != rhs.__isset.pt)
      return false;
    else if (__isset.pt && !(pt == rhs.pt))
      return false;
    if (__isset.color != rhs.__isset.color)
      return false;
    else if (__isset.color && !(color == rhs.color))
      return false;
    if (!(valid == rhs.valid))
      return false;
    return true;
  }
  bool operator != (const Track &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Track & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Track &a, Track &b);

inline std::ostream& operator<<(std::ostream& out, const Track& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ObservationRef__isset {
  _ObservationRef__isset() : frame(false), obs(false), valid(true) {}
  bool frame :1;
  bool obs :1;
  bool valid :1;
} _ObservationRef__isset;

class ObservationRef {
 public:

  ObservationRef(const ObservationRef&);
  ObservationRef& operator=(const ObservationRef&);
  ObservationRef() : frame(0), obs(0), valid(false) {
  }

  virtual ~ObservationRef() throw();
  int32_t frame;
  int32_t obs;
  bool valid;

  _ObservationRef__isset __isset;

  void __set_frame(const int32_t val);

  void __set_obs(const int32_t val);

  void __set_valid(const bool val);

  bool operator == (const ObservationRef & rhs) const
  {
    if (!(frame == rhs.frame))
      return false;
    if (!(obs == rhs.obs))
      return false;
    if (!(valid == rhs.valid))
      return false;
    return true;
  }
  bool operator != (const ObservationRef &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ObservationRef & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ObservationRef &a, ObservationRef &b);

inline std::ostream& operator<<(std::ostream& out, const ObservationRef& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Frame__isset {
  _Frame__isset() : obs(false), poses(false), cam(false), priorPoses(false) {}
  bool obs :1;
  bool poses :1;
  bool cam :1;
  bool priorPoses :1;
} _Frame__isset;

class Frame {
 public:

  Frame(const Frame&);
  Frame& operator=(const Frame&);
  Frame() {
  }

  virtual ~Frame() throw();
  std::vector<Observation>  obs;
  std::vector<std::vector<double> >  poses;
  std::vector<double>  cam;
  std::vector<std::vector<double> >  priorPoses;

  _Frame__isset __isset;

  void __set_obs(const std::vector<Observation> & val);

  void __set_poses(const std::vector<std::vector<double> > & val);

  void __set_cam(const std::vector<double> & val);

  void __set_priorPoses(const std::vector<std::vector<double> > & val);

  bool operator == (const Frame & rhs) const
  {
    if (!(obs == rhs.obs))
      return false;
    if (__isset.poses != rhs.__isset.poses)
      return false;
    else if (__isset.poses && !(poses == rhs.poses))
      return false;
    if (__isset.cam != rhs.__isset.cam)
      return false;
    else if (__isset.cam && !(cam == rhs.cam))
      return false;
    if (__isset.priorPoses != rhs.__isset.priorPoses)
      return false;
    else if (__isset.priorPoses && !(priorPoses == rhs.priorPoses))
      return false;
    return true;
  }
  bool operator != (const Frame &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Frame & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Frame &a, Frame &b);

inline std::ostream& operator<<(std::ostream& out, const Frame& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Session__isset {
  _Session__isset() : cam(false), frames(false), tracks(false), rs(false), scanlines(false), width(false), height(false) {}
  bool cam :1;
  bool frames :1;
  bool tracks :1;
  bool rs :1;
  bool scanlines :1;
  bool width :1;
  bool height :1;
} _Session__isset;

class Session {
 public:

  Session(const Session&);
  Session& operator=(const Session&);
  Session() : rs((RollingShutter::type)0), width(0), height(0) {
  }

  virtual ~Session() throw();
  std::vector<double>  cam;
  std::vector<Frame>  frames;
  std::vector<Track>  tracks;
  RollingShutter::type rs;
  std::vector<int32_t>  scanlines;
  int32_t width;
  int32_t height;

  _Session__isset __isset;

  void __set_cam(const std::vector<double> & val);

  void __set_frames(const std::vector<Frame> & val);

  void __set_tracks(const std::vector<Track> & val);

  void __set_rs(const RollingShutter::type val);

  void __set_scanlines(const std::vector<int32_t> & val);

  void __set_width(const int32_t val);

  void __set_height(const int32_t val);

  bool operator == (const Session & rhs) const
  {
    if (!(cam == rhs.cam))
      return false;
    if (!(frames == rhs.frames))
      return false;
    if (!(tracks == rhs.tracks))
      return false;
    if (__isset.rs != rhs.__isset.rs)
      return false;
    else if (__isset.rs && !(rs == rhs.rs))
      return false;
    if (__isset.scanlines != rhs.__isset.scanlines)
      return false;
    else if (__isset.scanlines && !(scanlines == rhs.scanlines))
      return false;
    if (!(width == rhs.width))
      return false;
    if (!(height == rhs.height))
      return false;
    return true;
  }
  bool operator != (const Session &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Session & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Session &a, Session &b);

inline std::ostream& operator<<(std::ostream& out, const Session& obj)
{
  obj.printTo(out);
  return out;
}

}}} // namespace

#endif
