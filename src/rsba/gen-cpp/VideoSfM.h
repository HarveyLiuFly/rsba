/**
 * Autogenerated by Thrift Compiler (1.0.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef VideoSfM_H
#define VideoSfM_H

#include <thrift/TDispatchProcessor.h>
#include "sfm_types.h"

namespace vision { namespace sfm { namespace gen {

class VideoSfMIf {
 public:
  virtual ~VideoSfMIf() {}
  virtual void authenticate(std::string& _return) = 0;
  virtual int32_t newSession(const std::string& authToken, const std::vector<double> & camera) = 0;
  virtual int32_t cloneSession(const std::string& authToken, const int32_t oldSessionKey) = 0;
  virtual int32_t newRsSession(const std::string& authToken, const std::vector<double> & camera, const RollingShutter::type rs, const std::vector<int32_t> & scanlines) = 0;
  virtual int32_t newFrame(const std::string& authToken, const int32_t sessionKey, const Frame& frame) = 0;
  virtual void getFrame(Frame& _return, const std::string& authToken, const int32_t sessionKey, const int32_t frameKey) = 0;
  virtual int32_t newTrack(const std::string& authToken, const int32_t sessionKey, const Track& track) = 0;
  virtual void getTracks(std::vector<Track> & _return, const std::string& authToken, const int32_t sessionKey) = 0;
  virtual void initialize(const std::string& authToken, const int32_t sessionKey) = 0;
  virtual bool fullBA(const std::string& authToken, const int32_t sessionKey, const int32_t maxIter, const bool reproject) = 0;
  virtual bool windowedBA(const std::string& authToken, const int32_t sessionKey, const int32_t startFrame, const int32_t endFrame, const int32_t maxIter, const bool reproject) = 0;
  virtual void finalize(const std::string& authToken, const int32_t sessionKey) = 0;
};

class VideoSfMIfFactory {
 public:
  typedef VideoSfMIf Handler;

  virtual ~VideoSfMIfFactory() {}

  virtual VideoSfMIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) = 0;
  virtual void releaseHandler(VideoSfMIf* /* handler */) = 0;
};

class VideoSfMIfSingletonFactory : virtual public VideoSfMIfFactory {
 public:
  VideoSfMIfSingletonFactory(const boost::shared_ptr<VideoSfMIf>& iface) : iface_(iface) {}
  virtual ~VideoSfMIfSingletonFactory() {}

  virtual VideoSfMIf* getHandler(const ::apache::thrift::TConnectionInfo&) {
    return iface_.get();
  }
  virtual void releaseHandler(VideoSfMIf* /* handler */) {}

 protected:
  boost::shared_ptr<VideoSfMIf> iface_;
};

class VideoSfMNull : virtual public VideoSfMIf {
 public:
  virtual ~VideoSfMNull() {}
  void authenticate(std::string& /* _return */) {
    return;
  }
  int32_t newSession(const std::string& /* authToken */, const std::vector<double> & /* camera */) {
    int32_t _return = 0;
    return _return;
  }
  int32_t cloneSession(const std::string& /* authToken */, const int32_t /* oldSessionKey */) {
    int32_t _return = 0;
    return _return;
  }
  int32_t newRsSession(const std::string& /* authToken */, const std::vector<double> & /* camera */, const RollingShutter::type /* rs */, const std::vector<int32_t> & /* scanlines */) {
    int32_t _return = 0;
    return _return;
  }
  int32_t newFrame(const std::string& /* authToken */, const int32_t /* sessionKey */, const Frame& /* frame */) {
    int32_t _return = 0;
    return _return;
  }
  void getFrame(Frame& /* _return */, const std::string& /* authToken */, const int32_t /* sessionKey */, const int32_t /* frameKey */) {
    return;
  }
  int32_t newTrack(const std::string& /* authToken */, const int32_t /* sessionKey */, const Track& /* track */) {
    int32_t _return = 0;
    return _return;
  }
  void getTracks(std::vector<Track> & /* _return */, const std::string& /* authToken */, const int32_t /* sessionKey */) {
    return;
  }
  void initialize(const std::string& /* authToken */, const int32_t /* sessionKey */) {
    return;
  }
  bool fullBA(const std::string& /* authToken */, const int32_t /* sessionKey */, const int32_t /* maxIter */, const bool /* reproject */) {
    bool _return = false;
    return _return;
  }
  bool windowedBA(const std::string& /* authToken */, const int32_t /* sessionKey */, const int32_t /* startFrame */, const int32_t /* endFrame */, const int32_t /* maxIter */, const bool /* reproject */) {
    bool _return = false;
    return _return;
  }
  void finalize(const std::string& /* authToken */, const int32_t /* sessionKey */) {
    return;
  }
};


class VideoSfM_authenticate_args {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

  VideoSfM_authenticate_args(const VideoSfM_authenticate_args&);
  VideoSfM_authenticate_args& operator=(const VideoSfM_authenticate_args&);
  VideoSfM_authenticate_args() {
  }

  virtual ~VideoSfM_authenticate_args() throw();

  bool operator == (const VideoSfM_authenticate_args & /* rhs */) const
  {
    return true;
  }
  bool operator != (const VideoSfM_authenticate_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_authenticate_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class VideoSfM_authenticate_pargs {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};


  virtual ~VideoSfM_authenticate_pargs() throw();

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _VideoSfM_authenticate_result__isset {
  _VideoSfM_authenticate_result__isset() : success(false) {}
  bool success;
} _VideoSfM_authenticate_result__isset;

class VideoSfM_authenticate_result {
 public:

  static const char* ascii_fingerprint; // = "9A73381FEFD6B67F432E717102246330";
  static const uint8_t binary_fingerprint[16]; // = {0x9A,0x73,0x38,0x1F,0xEF,0xD6,0xB6,0x7F,0x43,0x2E,0x71,0x71,0x02,0x24,0x63,0x30};

  VideoSfM_authenticate_result(const VideoSfM_authenticate_result&);
  VideoSfM_authenticate_result& operator=(const VideoSfM_authenticate_result&);
  VideoSfM_authenticate_result() : success() {
  }

  virtual ~VideoSfM_authenticate_result() throw();
  std::string success;

  _VideoSfM_authenticate_result__isset __isset;

  void __set_success(const std::string& val);

  bool operator == (const VideoSfM_authenticate_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const VideoSfM_authenticate_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_authenticate_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _VideoSfM_authenticate_presult__isset {
  _VideoSfM_authenticate_presult__isset() : success(false) {}
  bool success;
} _VideoSfM_authenticate_presult__isset;

class VideoSfM_authenticate_presult {
 public:

  static const char* ascii_fingerprint; // = "9A73381FEFD6B67F432E717102246330";
  static const uint8_t binary_fingerprint[16]; // = {0x9A,0x73,0x38,0x1F,0xEF,0xD6,0xB6,0x7F,0x43,0x2E,0x71,0x71,0x02,0x24,0x63,0x30};


  virtual ~VideoSfM_authenticate_presult() throw();
  std::string* success;

  _VideoSfM_authenticate_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _VideoSfM_newSession_args__isset {
  _VideoSfM_newSession_args__isset() : authToken(false), camera(false) {}
  bool authToken;
  bool camera;
} _VideoSfM_newSession_args__isset;

class VideoSfM_newSession_args {
 public:

  static const char* ascii_fingerprint; // = "061F1470A5BFC7F82E73CA7B179FFF41";
  static const uint8_t binary_fingerprint[16]; // = {0x06,0x1F,0x14,0x70,0xA5,0xBF,0xC7,0xF8,0x2E,0x73,0xCA,0x7B,0x17,0x9F,0xFF,0x41};

  VideoSfM_newSession_args(const VideoSfM_newSession_args&);
  VideoSfM_newSession_args& operator=(const VideoSfM_newSession_args&);
  VideoSfM_newSession_args() : authToken() {
  }

  virtual ~VideoSfM_newSession_args() throw();
  std::string authToken;
  std::vector<double>  camera;

  _VideoSfM_newSession_args__isset __isset;

  void __set_authToken(const std::string& val);

  void __set_camera(const std::vector<double> & val);

  bool operator == (const VideoSfM_newSession_args & rhs) const
  {
    if (!(authToken == rhs.authToken))
      return false;
    if (!(camera == rhs.camera))
      return false;
    return true;
  }
  bool operator != (const VideoSfM_newSession_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_newSession_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class VideoSfM_newSession_pargs {
 public:

  static const char* ascii_fingerprint; // = "061F1470A5BFC7F82E73CA7B179FFF41";
  static const uint8_t binary_fingerprint[16]; // = {0x06,0x1F,0x14,0x70,0xA5,0xBF,0xC7,0xF8,0x2E,0x73,0xCA,0x7B,0x17,0x9F,0xFF,0x41};


  virtual ~VideoSfM_newSession_pargs() throw();
  const std::string* authToken;
  const std::vector<double> * camera;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _VideoSfM_newSession_result__isset {
  _VideoSfM_newSession_result__isset() : success(false) {}
  bool success;
} _VideoSfM_newSession_result__isset;

class VideoSfM_newSession_result {
 public:

  static const char* ascii_fingerprint; // = "32183C4A04E706C58ED2F62566DDD8DE";
  static const uint8_t binary_fingerprint[16]; // = {0x32,0x18,0x3C,0x4A,0x04,0xE7,0x06,0xC5,0x8E,0xD2,0xF6,0x25,0x66,0xDD,0xD8,0xDE};

  VideoSfM_newSession_result(const VideoSfM_newSession_result&);
  VideoSfM_newSession_result& operator=(const VideoSfM_newSession_result&);
  VideoSfM_newSession_result() : success(0) {
  }

  virtual ~VideoSfM_newSession_result() throw();
  int32_t success;

  _VideoSfM_newSession_result__isset __isset;

  void __set_success(const int32_t val);

  bool operator == (const VideoSfM_newSession_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const VideoSfM_newSession_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_newSession_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _VideoSfM_newSession_presult__isset {
  _VideoSfM_newSession_presult__isset() : success(false) {}
  bool success;
} _VideoSfM_newSession_presult__isset;

class VideoSfM_newSession_presult {
 public:

  static const char* ascii_fingerprint; // = "32183C4A04E706C58ED2F62566DDD8DE";
  static const uint8_t binary_fingerprint[16]; // = {0x32,0x18,0x3C,0x4A,0x04,0xE7,0x06,0xC5,0x8E,0xD2,0xF6,0x25,0x66,0xDD,0xD8,0xDE};


  virtual ~VideoSfM_newSession_presult() throw();
  int32_t* success;

  _VideoSfM_newSession_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _VideoSfM_cloneSession_args__isset {
  _VideoSfM_cloneSession_args__isset() : authToken(false), oldSessionKey(false) {}
  bool authToken;
  bool oldSessionKey;
} _VideoSfM_cloneSession_args__isset;

class VideoSfM_cloneSession_args {
 public:

  static const char* ascii_fingerprint; // = "EEBC915CE44901401D881E6091423036";
  static const uint8_t binary_fingerprint[16]; // = {0xEE,0xBC,0x91,0x5C,0xE4,0x49,0x01,0x40,0x1D,0x88,0x1E,0x60,0x91,0x42,0x30,0x36};

  VideoSfM_cloneSession_args(const VideoSfM_cloneSession_args&);
  VideoSfM_cloneSession_args& operator=(const VideoSfM_cloneSession_args&);
  VideoSfM_cloneSession_args() : authToken(), oldSessionKey(0) {
  }

  virtual ~VideoSfM_cloneSession_args() throw();
  std::string authToken;
  int32_t oldSessionKey;

  _VideoSfM_cloneSession_args__isset __isset;

  void __set_authToken(const std::string& val);

  void __set_oldSessionKey(const int32_t val);

  bool operator == (const VideoSfM_cloneSession_args & rhs) const
  {
    if (!(authToken == rhs.authToken))
      return false;
    if (!(oldSessionKey == rhs.oldSessionKey))
      return false;
    return true;
  }
  bool operator != (const VideoSfM_cloneSession_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_cloneSession_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class VideoSfM_cloneSession_pargs {
 public:

  static const char* ascii_fingerprint; // = "EEBC915CE44901401D881E6091423036";
  static const uint8_t binary_fingerprint[16]; // = {0xEE,0xBC,0x91,0x5C,0xE4,0x49,0x01,0x40,0x1D,0x88,0x1E,0x60,0x91,0x42,0x30,0x36};


  virtual ~VideoSfM_cloneSession_pargs() throw();
  const std::string* authToken;
  const int32_t* oldSessionKey;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _VideoSfM_cloneSession_result__isset {
  _VideoSfM_cloneSession_result__isset() : success(false) {}
  bool success;
} _VideoSfM_cloneSession_result__isset;

class VideoSfM_cloneSession_result {
 public:

  static const char* ascii_fingerprint; // = "32183C4A04E706C58ED2F62566DDD8DE";
  static const uint8_t binary_fingerprint[16]; // = {0x32,0x18,0x3C,0x4A,0x04,0xE7,0x06,0xC5,0x8E,0xD2,0xF6,0x25,0x66,0xDD,0xD8,0xDE};

  VideoSfM_cloneSession_result(const VideoSfM_cloneSession_result&);
  VideoSfM_cloneSession_result& operator=(const VideoSfM_cloneSession_result&);
  VideoSfM_cloneSession_result() : success(0) {
  }

  virtual ~VideoSfM_cloneSession_result() throw();
  int32_t success;

  _VideoSfM_cloneSession_result__isset __isset;

  void __set_success(const int32_t val);

  bool operator == (const VideoSfM_cloneSession_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const VideoSfM_cloneSession_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_cloneSession_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _VideoSfM_cloneSession_presult__isset {
  _VideoSfM_cloneSession_presult__isset() : success(false) {}
  bool success;
} _VideoSfM_cloneSession_presult__isset;

class VideoSfM_cloneSession_presult {
 public:

  static const char* ascii_fingerprint; // = "32183C4A04E706C58ED2F62566DDD8DE";
  static const uint8_t binary_fingerprint[16]; // = {0x32,0x18,0x3C,0x4A,0x04,0xE7,0x06,0xC5,0x8E,0xD2,0xF6,0x25,0x66,0xDD,0xD8,0xDE};


  virtual ~VideoSfM_cloneSession_presult() throw();
  int32_t* success;

  _VideoSfM_cloneSession_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _VideoSfM_newRsSession_args__isset {
  _VideoSfM_newRsSession_args__isset() : authToken(false), camera(false), rs(false), scanlines(false) {}
  bool authToken;
  bool camera;
  bool rs;
  bool scanlines;
} _VideoSfM_newRsSession_args__isset;

class VideoSfM_newRsSession_args {
 public:

  static const char* ascii_fingerprint; // = "AF773E59A5A7244A76AED5F993B37CBE";
  static const uint8_t binary_fingerprint[16]; // = {0xAF,0x77,0x3E,0x59,0xA5,0xA7,0x24,0x4A,0x76,0xAE,0xD5,0xF9,0x93,0xB3,0x7C,0xBE};

  VideoSfM_newRsSession_args(const VideoSfM_newRsSession_args&);
  VideoSfM_newRsSession_args& operator=(const VideoSfM_newRsSession_args&);
  VideoSfM_newRsSession_args() : authToken(), rs((RollingShutter::type)0) {
  }

  virtual ~VideoSfM_newRsSession_args() throw();
  std::string authToken;
  std::vector<double>  camera;
  RollingShutter::type rs;
  std::vector<int32_t>  scanlines;

  _VideoSfM_newRsSession_args__isset __isset;

  void __set_authToken(const std::string& val);

  void __set_camera(const std::vector<double> & val);

  void __set_rs(const RollingShutter::type val);

  void __set_scanlines(const std::vector<int32_t> & val);

  bool operator == (const VideoSfM_newRsSession_args & rhs) const
  {
    if (!(authToken == rhs.authToken))
      return false;
    if (!(camera == rhs.camera))
      return false;
    if (!(rs == rhs.rs))
      return false;
    if (!(scanlines == rhs.scanlines))
      return false;
    return true;
  }
  bool operator != (const VideoSfM_newRsSession_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_newRsSession_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class VideoSfM_newRsSession_pargs {
 public:

  static const char* ascii_fingerprint; // = "AF773E59A5A7244A76AED5F993B37CBE";
  static const uint8_t binary_fingerprint[16]; // = {0xAF,0x77,0x3E,0x59,0xA5,0xA7,0x24,0x4A,0x76,0xAE,0xD5,0xF9,0x93,0xB3,0x7C,0xBE};


  virtual ~VideoSfM_newRsSession_pargs() throw();
  const std::string* authToken;
  const std::vector<double> * camera;
  const RollingShutter::type* rs;
  const std::vector<int32_t> * scanlines;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _VideoSfM_newRsSession_result__isset {
  _VideoSfM_newRsSession_result__isset() : success(false) {}
  bool success;
} _VideoSfM_newRsSession_result__isset;

class VideoSfM_newRsSession_result {
 public:

  static const char* ascii_fingerprint; // = "32183C4A04E706C58ED2F62566DDD8DE";
  static const uint8_t binary_fingerprint[16]; // = {0x32,0x18,0x3C,0x4A,0x04,0xE7,0x06,0xC5,0x8E,0xD2,0xF6,0x25,0x66,0xDD,0xD8,0xDE};

  VideoSfM_newRsSession_result(const VideoSfM_newRsSession_result&);
  VideoSfM_newRsSession_result& operator=(const VideoSfM_newRsSession_result&);
  VideoSfM_newRsSession_result() : success(0) {
  }

  virtual ~VideoSfM_newRsSession_result() throw();
  int32_t success;

  _VideoSfM_newRsSession_result__isset __isset;

  void __set_success(const int32_t val);

  bool operator == (const VideoSfM_newRsSession_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const VideoSfM_newRsSession_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_newRsSession_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _VideoSfM_newRsSession_presult__isset {
  _VideoSfM_newRsSession_presult__isset() : success(false) {}
  bool success;
} _VideoSfM_newRsSession_presult__isset;

class VideoSfM_newRsSession_presult {
 public:

  static const char* ascii_fingerprint; // = "32183C4A04E706C58ED2F62566DDD8DE";
  static const uint8_t binary_fingerprint[16]; // = {0x32,0x18,0x3C,0x4A,0x04,0xE7,0x06,0xC5,0x8E,0xD2,0xF6,0x25,0x66,0xDD,0xD8,0xDE};


  virtual ~VideoSfM_newRsSession_presult() throw();
  int32_t* success;

  _VideoSfM_newRsSession_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _VideoSfM_newFrame_args__isset {
  _VideoSfM_newFrame_args__isset() : authToken(false), sessionKey(false), frame(false) {}
  bool authToken;
  bool sessionKey;
  bool frame;
} _VideoSfM_newFrame_args__isset;

class VideoSfM_newFrame_args {
 public:

  static const char* ascii_fingerprint; // = "FF6F929315A9023249788F6783F1007A";
  static const uint8_t binary_fingerprint[16]; // = {0xFF,0x6F,0x92,0x93,0x15,0xA9,0x02,0x32,0x49,0x78,0x8F,0x67,0x83,0xF1,0x00,0x7A};

  VideoSfM_newFrame_args(const VideoSfM_newFrame_args&);
  VideoSfM_newFrame_args& operator=(const VideoSfM_newFrame_args&);
  VideoSfM_newFrame_args() : authToken(), sessionKey(0) {
  }

  virtual ~VideoSfM_newFrame_args() throw();
  std::string authToken;
  int32_t sessionKey;
  Frame frame;

  _VideoSfM_newFrame_args__isset __isset;

  void __set_authToken(const std::string& val);

  void __set_sessionKey(const int32_t val);

  void __set_frame(const Frame& val);

  bool operator == (const VideoSfM_newFrame_args & rhs) const
  {
    if (!(authToken == rhs.authToken))
      return false;
    if (!(sessionKey == rhs.sessionKey))
      return false;
    if (!(frame == rhs.frame))
      return false;
    return true;
  }
  bool operator != (const VideoSfM_newFrame_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_newFrame_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class VideoSfM_newFrame_pargs {
 public:

  static const char* ascii_fingerprint; // = "FF6F929315A9023249788F6783F1007A";
  static const uint8_t binary_fingerprint[16]; // = {0xFF,0x6F,0x92,0x93,0x15,0xA9,0x02,0x32,0x49,0x78,0x8F,0x67,0x83,0xF1,0x00,0x7A};


  virtual ~VideoSfM_newFrame_pargs() throw();
  const std::string* authToken;
  const int32_t* sessionKey;
  const Frame* frame;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _VideoSfM_newFrame_result__isset {
  _VideoSfM_newFrame_result__isset() : success(false) {}
  bool success;
} _VideoSfM_newFrame_result__isset;

class VideoSfM_newFrame_result {
 public:

  static const char* ascii_fingerprint; // = "32183C4A04E706C58ED2F62566DDD8DE";
  static const uint8_t binary_fingerprint[16]; // = {0x32,0x18,0x3C,0x4A,0x04,0xE7,0x06,0xC5,0x8E,0xD2,0xF6,0x25,0x66,0xDD,0xD8,0xDE};

  VideoSfM_newFrame_result(const VideoSfM_newFrame_result&);
  VideoSfM_newFrame_result& operator=(const VideoSfM_newFrame_result&);
  VideoSfM_newFrame_result() : success(0) {
  }

  virtual ~VideoSfM_newFrame_result() throw();
  int32_t success;

  _VideoSfM_newFrame_result__isset __isset;

  void __set_success(const int32_t val);

  bool operator == (const VideoSfM_newFrame_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const VideoSfM_newFrame_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_newFrame_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _VideoSfM_newFrame_presult__isset {
  _VideoSfM_newFrame_presult__isset() : success(false) {}
  bool success;
} _VideoSfM_newFrame_presult__isset;

class VideoSfM_newFrame_presult {
 public:

  static const char* ascii_fingerprint; // = "32183C4A04E706C58ED2F62566DDD8DE";
  static const uint8_t binary_fingerprint[16]; // = {0x32,0x18,0x3C,0x4A,0x04,0xE7,0x06,0xC5,0x8E,0xD2,0xF6,0x25,0x66,0xDD,0xD8,0xDE};


  virtual ~VideoSfM_newFrame_presult() throw();
  int32_t* success;

  _VideoSfM_newFrame_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _VideoSfM_getFrame_args__isset {
  _VideoSfM_getFrame_args__isset() : authToken(false), sessionKey(false), frameKey(false) {}
  bool authToken;
  bool sessionKey;
  bool frameKey;
} _VideoSfM_getFrame_args__isset;

class VideoSfM_getFrame_args {
 public:

  static const char* ascii_fingerprint; // = "28C2ECC89260BADB9C70330FBF47BFA8";
  static const uint8_t binary_fingerprint[16]; // = {0x28,0xC2,0xEC,0xC8,0x92,0x60,0xBA,0xDB,0x9C,0x70,0x33,0x0F,0xBF,0x47,0xBF,0xA8};

  VideoSfM_getFrame_args(const VideoSfM_getFrame_args&);
  VideoSfM_getFrame_args& operator=(const VideoSfM_getFrame_args&);
  VideoSfM_getFrame_args() : authToken(), sessionKey(0), frameKey(0) {
  }

  virtual ~VideoSfM_getFrame_args() throw();
  std::string authToken;
  int32_t sessionKey;
  int32_t frameKey;

  _VideoSfM_getFrame_args__isset __isset;

  void __set_authToken(const std::string& val);

  void __set_sessionKey(const int32_t val);

  void __set_frameKey(const int32_t val);

  bool operator == (const VideoSfM_getFrame_args & rhs) const
  {
    if (!(authToken == rhs.authToken))
      return false;
    if (!(sessionKey == rhs.sessionKey))
      return false;
    if (!(frameKey == rhs.frameKey))
      return false;
    return true;
  }
  bool operator != (const VideoSfM_getFrame_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_getFrame_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class VideoSfM_getFrame_pargs {
 public:

  static const char* ascii_fingerprint; // = "28C2ECC89260BADB9C70330FBF47BFA8";
  static const uint8_t binary_fingerprint[16]; // = {0x28,0xC2,0xEC,0xC8,0x92,0x60,0xBA,0xDB,0x9C,0x70,0x33,0x0F,0xBF,0x47,0xBF,0xA8};


  virtual ~VideoSfM_getFrame_pargs() throw();
  const std::string* authToken;
  const int32_t* sessionKey;
  const int32_t* frameKey;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _VideoSfM_getFrame_result__isset {
  _VideoSfM_getFrame_result__isset() : success(false) {}
  bool success;
} _VideoSfM_getFrame_result__isset;

class VideoSfM_getFrame_result {
 public:

  static const char* ascii_fingerprint; // = "56C0549121CC1B9A713927F1CC0E95C4";
  static const uint8_t binary_fingerprint[16]; // = {0x56,0xC0,0x54,0x91,0x21,0xCC,0x1B,0x9A,0x71,0x39,0x27,0xF1,0xCC,0x0E,0x95,0xC4};

  VideoSfM_getFrame_result(const VideoSfM_getFrame_result&);
  VideoSfM_getFrame_result& operator=(const VideoSfM_getFrame_result&);
  VideoSfM_getFrame_result() {
  }

  virtual ~VideoSfM_getFrame_result() throw();
  Frame success;

  _VideoSfM_getFrame_result__isset __isset;

  void __set_success(const Frame& val);

  bool operator == (const VideoSfM_getFrame_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const VideoSfM_getFrame_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_getFrame_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _VideoSfM_getFrame_presult__isset {
  _VideoSfM_getFrame_presult__isset() : success(false) {}
  bool success;
} _VideoSfM_getFrame_presult__isset;

class VideoSfM_getFrame_presult {
 public:

  static const char* ascii_fingerprint; // = "56C0549121CC1B9A713927F1CC0E95C4";
  static const uint8_t binary_fingerprint[16]; // = {0x56,0xC0,0x54,0x91,0x21,0xCC,0x1B,0x9A,0x71,0x39,0x27,0xF1,0xCC,0x0E,0x95,0xC4};


  virtual ~VideoSfM_getFrame_presult() throw();
  Frame* success;

  _VideoSfM_getFrame_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _VideoSfM_newTrack_args__isset {
  _VideoSfM_newTrack_args__isset() : authToken(false), sessionKey(false), track(false) {}
  bool authToken;
  bool sessionKey;
  bool track;
} _VideoSfM_newTrack_args__isset;

class VideoSfM_newTrack_args {
 public:

  static const char* ascii_fingerprint; // = "7D142A26EC5AF0B61C813F91CB6819F1";
  static const uint8_t binary_fingerprint[16]; // = {0x7D,0x14,0x2A,0x26,0xEC,0x5A,0xF0,0xB6,0x1C,0x81,0x3F,0x91,0xCB,0x68,0x19,0xF1};

  VideoSfM_newTrack_args(const VideoSfM_newTrack_args&);
  VideoSfM_newTrack_args& operator=(const VideoSfM_newTrack_args&);
  VideoSfM_newTrack_args() : authToken(), sessionKey(0) {
  }

  virtual ~VideoSfM_newTrack_args() throw();
  std::string authToken;
  int32_t sessionKey;
  Track track;

  _VideoSfM_newTrack_args__isset __isset;

  void __set_authToken(const std::string& val);

  void __set_sessionKey(const int32_t val);

  void __set_track(const Track& val);

  bool operator == (const VideoSfM_newTrack_args & rhs) const
  {
    if (!(authToken == rhs.authToken))
      return false;
    if (!(sessionKey == rhs.sessionKey))
      return false;
    if (!(track == rhs.track))
      return false;
    return true;
  }
  bool operator != (const VideoSfM_newTrack_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_newTrack_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class VideoSfM_newTrack_pargs {
 public:

  static const char* ascii_fingerprint; // = "7D142A26EC5AF0B61C813F91CB6819F1";
  static const uint8_t binary_fingerprint[16]; // = {0x7D,0x14,0x2A,0x26,0xEC,0x5A,0xF0,0xB6,0x1C,0x81,0x3F,0x91,0xCB,0x68,0x19,0xF1};


  virtual ~VideoSfM_newTrack_pargs() throw();
  const std::string* authToken;
  const int32_t* sessionKey;
  const Track* track;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _VideoSfM_newTrack_result__isset {
  _VideoSfM_newTrack_result__isset() : success(false) {}
  bool success;
} _VideoSfM_newTrack_result__isset;

class VideoSfM_newTrack_result {
 public:

  static const char* ascii_fingerprint; // = "32183C4A04E706C58ED2F62566DDD8DE";
  static const uint8_t binary_fingerprint[16]; // = {0x32,0x18,0x3C,0x4A,0x04,0xE7,0x06,0xC5,0x8E,0xD2,0xF6,0x25,0x66,0xDD,0xD8,0xDE};

  VideoSfM_newTrack_result(const VideoSfM_newTrack_result&);
  VideoSfM_newTrack_result& operator=(const VideoSfM_newTrack_result&);
  VideoSfM_newTrack_result() : success(0) {
  }

  virtual ~VideoSfM_newTrack_result() throw();
  int32_t success;

  _VideoSfM_newTrack_result__isset __isset;

  void __set_success(const int32_t val);

  bool operator == (const VideoSfM_newTrack_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const VideoSfM_newTrack_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_newTrack_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _VideoSfM_newTrack_presult__isset {
  _VideoSfM_newTrack_presult__isset() : success(false) {}
  bool success;
} _VideoSfM_newTrack_presult__isset;

class VideoSfM_newTrack_presult {
 public:

  static const char* ascii_fingerprint; // = "32183C4A04E706C58ED2F62566DDD8DE";
  static const uint8_t binary_fingerprint[16]; // = {0x32,0x18,0x3C,0x4A,0x04,0xE7,0x06,0xC5,0x8E,0xD2,0xF6,0x25,0x66,0xDD,0xD8,0xDE};


  virtual ~VideoSfM_newTrack_presult() throw();
  int32_t* success;

  _VideoSfM_newTrack_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _VideoSfM_getTracks_args__isset {
  _VideoSfM_getTracks_args__isset() : authToken(false), sessionKey(false) {}
  bool authToken;
  bool sessionKey;
} _VideoSfM_getTracks_args__isset;

class VideoSfM_getTracks_args {
 public:

  static const char* ascii_fingerprint; // = "EEBC915CE44901401D881E6091423036";
  static const uint8_t binary_fingerprint[16]; // = {0xEE,0xBC,0x91,0x5C,0xE4,0x49,0x01,0x40,0x1D,0x88,0x1E,0x60,0x91,0x42,0x30,0x36};

  VideoSfM_getTracks_args(const VideoSfM_getTracks_args&);
  VideoSfM_getTracks_args& operator=(const VideoSfM_getTracks_args&);
  VideoSfM_getTracks_args() : authToken(), sessionKey(0) {
  }

  virtual ~VideoSfM_getTracks_args() throw();
  std::string authToken;
  int32_t sessionKey;

  _VideoSfM_getTracks_args__isset __isset;

  void __set_authToken(const std::string& val);

  void __set_sessionKey(const int32_t val);

  bool operator == (const VideoSfM_getTracks_args & rhs) const
  {
    if (!(authToken == rhs.authToken))
      return false;
    if (!(sessionKey == rhs.sessionKey))
      return false;
    return true;
  }
  bool operator != (const VideoSfM_getTracks_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_getTracks_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class VideoSfM_getTracks_pargs {
 public:

  static const char* ascii_fingerprint; // = "EEBC915CE44901401D881E6091423036";
  static const uint8_t binary_fingerprint[16]; // = {0xEE,0xBC,0x91,0x5C,0xE4,0x49,0x01,0x40,0x1D,0x88,0x1E,0x60,0x91,0x42,0x30,0x36};


  virtual ~VideoSfM_getTracks_pargs() throw();
  const std::string* authToken;
  const int32_t* sessionKey;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _VideoSfM_getTracks_result__isset {
  _VideoSfM_getTracks_result__isset() : success(false) {}
  bool success;
} _VideoSfM_getTracks_result__isset;

class VideoSfM_getTracks_result {
 public:

  static const char* ascii_fingerprint; // = "D465B3EF3C27C682B79D432FF86F2CF9";
  static const uint8_t binary_fingerprint[16]; // = {0xD4,0x65,0xB3,0xEF,0x3C,0x27,0xC6,0x82,0xB7,0x9D,0x43,0x2F,0xF8,0x6F,0x2C,0xF9};

  VideoSfM_getTracks_result(const VideoSfM_getTracks_result&);
  VideoSfM_getTracks_result& operator=(const VideoSfM_getTracks_result&);
  VideoSfM_getTracks_result() {
  }

  virtual ~VideoSfM_getTracks_result() throw();
  std::vector<Track>  success;

  _VideoSfM_getTracks_result__isset __isset;

  void __set_success(const std::vector<Track> & val);

  bool operator == (const VideoSfM_getTracks_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const VideoSfM_getTracks_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_getTracks_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _VideoSfM_getTracks_presult__isset {
  _VideoSfM_getTracks_presult__isset() : success(false) {}
  bool success;
} _VideoSfM_getTracks_presult__isset;

class VideoSfM_getTracks_presult {
 public:

  static const char* ascii_fingerprint; // = "D465B3EF3C27C682B79D432FF86F2CF9";
  static const uint8_t binary_fingerprint[16]; // = {0xD4,0x65,0xB3,0xEF,0x3C,0x27,0xC6,0x82,0xB7,0x9D,0x43,0x2F,0xF8,0x6F,0x2C,0xF9};


  virtual ~VideoSfM_getTracks_presult() throw();
  std::vector<Track> * success;

  _VideoSfM_getTracks_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _VideoSfM_initialize_args__isset {
  _VideoSfM_initialize_args__isset() : authToken(false), sessionKey(false) {}
  bool authToken;
  bool sessionKey;
} _VideoSfM_initialize_args__isset;

class VideoSfM_initialize_args {
 public:

  static const char* ascii_fingerprint; // = "EEBC915CE44901401D881E6091423036";
  static const uint8_t binary_fingerprint[16]; // = {0xEE,0xBC,0x91,0x5C,0xE4,0x49,0x01,0x40,0x1D,0x88,0x1E,0x60,0x91,0x42,0x30,0x36};

  VideoSfM_initialize_args(const VideoSfM_initialize_args&);
  VideoSfM_initialize_args& operator=(const VideoSfM_initialize_args&);
  VideoSfM_initialize_args() : authToken(), sessionKey(0) {
  }

  virtual ~VideoSfM_initialize_args() throw();
  std::string authToken;
  int32_t sessionKey;

  _VideoSfM_initialize_args__isset __isset;

  void __set_authToken(const std::string& val);

  void __set_sessionKey(const int32_t val);

  bool operator == (const VideoSfM_initialize_args & rhs) const
  {
    if (!(authToken == rhs.authToken))
      return false;
    if (!(sessionKey == rhs.sessionKey))
      return false;
    return true;
  }
  bool operator != (const VideoSfM_initialize_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_initialize_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class VideoSfM_initialize_pargs {
 public:

  static const char* ascii_fingerprint; // = "EEBC915CE44901401D881E6091423036";
  static const uint8_t binary_fingerprint[16]; // = {0xEE,0xBC,0x91,0x5C,0xE4,0x49,0x01,0x40,0x1D,0x88,0x1E,0x60,0x91,0x42,0x30,0x36};


  virtual ~VideoSfM_initialize_pargs() throw();
  const std::string* authToken;
  const int32_t* sessionKey;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class VideoSfM_initialize_result {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

  VideoSfM_initialize_result(const VideoSfM_initialize_result&);
  VideoSfM_initialize_result& operator=(const VideoSfM_initialize_result&);
  VideoSfM_initialize_result() {
  }

  virtual ~VideoSfM_initialize_result() throw();

  bool operator == (const VideoSfM_initialize_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const VideoSfM_initialize_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_initialize_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class VideoSfM_initialize_presult {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};


  virtual ~VideoSfM_initialize_presult() throw();

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _VideoSfM_fullBA_args__isset {
  _VideoSfM_fullBA_args__isset() : authToken(false), sessionKey(false), maxIter(false), reproject(true) {}
  bool authToken;
  bool sessionKey;
  bool maxIter;
  bool reproject;
} _VideoSfM_fullBA_args__isset;

class VideoSfM_fullBA_args {
 public:

  static const char* ascii_fingerprint; // = "3EFB2FD342708CE6D70E5515CDF46508";
  static const uint8_t binary_fingerprint[16]; // = {0x3E,0xFB,0x2F,0xD3,0x42,0x70,0x8C,0xE6,0xD7,0x0E,0x55,0x15,0xCD,0xF4,0x65,0x08};

  VideoSfM_fullBA_args(const VideoSfM_fullBA_args&);
  VideoSfM_fullBA_args& operator=(const VideoSfM_fullBA_args&);
  VideoSfM_fullBA_args() : authToken(), sessionKey(0), maxIter(0), reproject(false) {
  }

  virtual ~VideoSfM_fullBA_args() throw();
  std::string authToken;
  int32_t sessionKey;
  int32_t maxIter;
  bool reproject;

  _VideoSfM_fullBA_args__isset __isset;

  void __set_authToken(const std::string& val);

  void __set_sessionKey(const int32_t val);

  void __set_maxIter(const int32_t val);

  void __set_reproject(const bool val);

  bool operator == (const VideoSfM_fullBA_args & rhs) const
  {
    if (!(authToken == rhs.authToken))
      return false;
    if (!(sessionKey == rhs.sessionKey))
      return false;
    if (!(maxIter == rhs.maxIter))
      return false;
    if (!(reproject == rhs.reproject))
      return false;
    return true;
  }
  bool operator != (const VideoSfM_fullBA_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_fullBA_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class VideoSfM_fullBA_pargs {
 public:

  static const char* ascii_fingerprint; // = "3EFB2FD342708CE6D70E5515CDF46508";
  static const uint8_t binary_fingerprint[16]; // = {0x3E,0xFB,0x2F,0xD3,0x42,0x70,0x8C,0xE6,0xD7,0x0E,0x55,0x15,0xCD,0xF4,0x65,0x08};


  virtual ~VideoSfM_fullBA_pargs() throw();
  const std::string* authToken;
  const int32_t* sessionKey;
  const int32_t* maxIter;
  const bool* reproject;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _VideoSfM_fullBA_result__isset {
  _VideoSfM_fullBA_result__isset() : success(false) {}
  bool success;
} _VideoSfM_fullBA_result__isset;

class VideoSfM_fullBA_result {
 public:

  static const char* ascii_fingerprint; // = "D9D3B4421B1F23CB4063C80B484E7909";
  static const uint8_t binary_fingerprint[16]; // = {0xD9,0xD3,0xB4,0x42,0x1B,0x1F,0x23,0xCB,0x40,0x63,0xC8,0x0B,0x48,0x4E,0x79,0x09};

  VideoSfM_fullBA_result(const VideoSfM_fullBA_result&);
  VideoSfM_fullBA_result& operator=(const VideoSfM_fullBA_result&);
  VideoSfM_fullBA_result() : success(0) {
  }

  virtual ~VideoSfM_fullBA_result() throw();
  bool success;

  _VideoSfM_fullBA_result__isset __isset;

  void __set_success(const bool val);

  bool operator == (const VideoSfM_fullBA_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const VideoSfM_fullBA_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_fullBA_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _VideoSfM_fullBA_presult__isset {
  _VideoSfM_fullBA_presult__isset() : success(false) {}
  bool success;
} _VideoSfM_fullBA_presult__isset;

class VideoSfM_fullBA_presult {
 public:

  static const char* ascii_fingerprint; // = "D9D3B4421B1F23CB4063C80B484E7909";
  static const uint8_t binary_fingerprint[16]; // = {0xD9,0xD3,0xB4,0x42,0x1B,0x1F,0x23,0xCB,0x40,0x63,0xC8,0x0B,0x48,0x4E,0x79,0x09};


  virtual ~VideoSfM_fullBA_presult() throw();
  bool* success;

  _VideoSfM_fullBA_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _VideoSfM_windowedBA_args__isset {
  _VideoSfM_windowedBA_args__isset() : authToken(false), sessionKey(false), startFrame(false), endFrame(false), maxIter(false), reproject(true) {}
  bool authToken;
  bool sessionKey;
  bool startFrame;
  bool endFrame;
  bool maxIter;
  bool reproject;
} _VideoSfM_windowedBA_args__isset;

class VideoSfM_windowedBA_args {
 public:

  static const char* ascii_fingerprint; // = "F1F8E3F1E427C7EADB61795226E7B74D";
  static const uint8_t binary_fingerprint[16]; // = {0xF1,0xF8,0xE3,0xF1,0xE4,0x27,0xC7,0xEA,0xDB,0x61,0x79,0x52,0x26,0xE7,0xB7,0x4D};

  VideoSfM_windowedBA_args(const VideoSfM_windowedBA_args&);
  VideoSfM_windowedBA_args& operator=(const VideoSfM_windowedBA_args&);
  VideoSfM_windowedBA_args() : authToken(), sessionKey(0), startFrame(0), endFrame(0), maxIter(0), reproject(false) {
  }

  virtual ~VideoSfM_windowedBA_args() throw();
  std::string authToken;
  int32_t sessionKey;
  int32_t startFrame;
  int32_t endFrame;
  int32_t maxIter;
  bool reproject;

  _VideoSfM_windowedBA_args__isset __isset;

  void __set_authToken(const std::string& val);

  void __set_sessionKey(const int32_t val);

  void __set_startFrame(const int32_t val);

  void __set_endFrame(const int32_t val);

  void __set_maxIter(const int32_t val);

  void __set_reproject(const bool val);

  bool operator == (const VideoSfM_windowedBA_args & rhs) const
  {
    if (!(authToken == rhs.authToken))
      return false;
    if (!(sessionKey == rhs.sessionKey))
      return false;
    if (!(startFrame == rhs.startFrame))
      return false;
    if (!(endFrame == rhs.endFrame))
      return false;
    if (!(maxIter == rhs.maxIter))
      return false;
    if (!(reproject == rhs.reproject))
      return false;
    return true;
  }
  bool operator != (const VideoSfM_windowedBA_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_windowedBA_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class VideoSfM_windowedBA_pargs {
 public:

  static const char* ascii_fingerprint; // = "F1F8E3F1E427C7EADB61795226E7B74D";
  static const uint8_t binary_fingerprint[16]; // = {0xF1,0xF8,0xE3,0xF1,0xE4,0x27,0xC7,0xEA,0xDB,0x61,0x79,0x52,0x26,0xE7,0xB7,0x4D};


  virtual ~VideoSfM_windowedBA_pargs() throw();
  const std::string* authToken;
  const int32_t* sessionKey;
  const int32_t* startFrame;
  const int32_t* endFrame;
  const int32_t* maxIter;
  const bool* reproject;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _VideoSfM_windowedBA_result__isset {
  _VideoSfM_windowedBA_result__isset() : success(false) {}
  bool success;
} _VideoSfM_windowedBA_result__isset;

class VideoSfM_windowedBA_result {
 public:

  static const char* ascii_fingerprint; // = "D9D3B4421B1F23CB4063C80B484E7909";
  static const uint8_t binary_fingerprint[16]; // = {0xD9,0xD3,0xB4,0x42,0x1B,0x1F,0x23,0xCB,0x40,0x63,0xC8,0x0B,0x48,0x4E,0x79,0x09};

  VideoSfM_windowedBA_result(const VideoSfM_windowedBA_result&);
  VideoSfM_windowedBA_result& operator=(const VideoSfM_windowedBA_result&);
  VideoSfM_windowedBA_result() : success(0) {
  }

  virtual ~VideoSfM_windowedBA_result() throw();
  bool success;

  _VideoSfM_windowedBA_result__isset __isset;

  void __set_success(const bool val);

  bool operator == (const VideoSfM_windowedBA_result & rhs) const
  {
    if (!(success == rhs.success))
      return false;
    return true;
  }
  bool operator != (const VideoSfM_windowedBA_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_windowedBA_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

typedef struct _VideoSfM_windowedBA_presult__isset {
  _VideoSfM_windowedBA_presult__isset() : success(false) {}
  bool success;
} _VideoSfM_windowedBA_presult__isset;

class VideoSfM_windowedBA_presult {
 public:

  static const char* ascii_fingerprint; // = "D9D3B4421B1F23CB4063C80B484E7909";
  static const uint8_t binary_fingerprint[16]; // = {0xD9,0xD3,0xB4,0x42,0x1B,0x1F,0x23,0xCB,0x40,0x63,0xC8,0x0B,0x48,0x4E,0x79,0x09};


  virtual ~VideoSfM_windowedBA_presult() throw();
  bool* success;

  _VideoSfM_windowedBA_presult__isset __isset;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

typedef struct _VideoSfM_finalize_args__isset {
  _VideoSfM_finalize_args__isset() : authToken(false), sessionKey(false) {}
  bool authToken;
  bool sessionKey;
} _VideoSfM_finalize_args__isset;

class VideoSfM_finalize_args {
 public:

  static const char* ascii_fingerprint; // = "EEBC915CE44901401D881E6091423036";
  static const uint8_t binary_fingerprint[16]; // = {0xEE,0xBC,0x91,0x5C,0xE4,0x49,0x01,0x40,0x1D,0x88,0x1E,0x60,0x91,0x42,0x30,0x36};

  VideoSfM_finalize_args(const VideoSfM_finalize_args&);
  VideoSfM_finalize_args& operator=(const VideoSfM_finalize_args&);
  VideoSfM_finalize_args() : authToken(), sessionKey(0) {
  }

  virtual ~VideoSfM_finalize_args() throw();
  std::string authToken;
  int32_t sessionKey;

  _VideoSfM_finalize_args__isset __isset;

  void __set_authToken(const std::string& val);

  void __set_sessionKey(const int32_t val);

  bool operator == (const VideoSfM_finalize_args & rhs) const
  {
    if (!(authToken == rhs.authToken))
      return false;
    if (!(sessionKey == rhs.sessionKey))
      return false;
    return true;
  }
  bool operator != (const VideoSfM_finalize_args &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_finalize_args & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class VideoSfM_finalize_pargs {
 public:

  static const char* ascii_fingerprint; // = "EEBC915CE44901401D881E6091423036";
  static const uint8_t binary_fingerprint[16]; // = {0xEE,0xBC,0x91,0x5C,0xE4,0x49,0x01,0x40,0x1D,0x88,0x1E,0x60,0x91,0x42,0x30,0x36};


  virtual ~VideoSfM_finalize_pargs() throw();
  const std::string* authToken;
  const int32_t* sessionKey;

  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class VideoSfM_finalize_result {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};

  VideoSfM_finalize_result(const VideoSfM_finalize_result&);
  VideoSfM_finalize_result& operator=(const VideoSfM_finalize_result&);
  VideoSfM_finalize_result() {
  }

  virtual ~VideoSfM_finalize_result() throw();

  bool operator == (const VideoSfM_finalize_result & /* rhs */) const
  {
    return true;
  }
  bool operator != (const VideoSfM_finalize_result &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const VideoSfM_finalize_result & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};


class VideoSfM_finalize_presult {
 public:

  static const char* ascii_fingerprint; // = "99914B932BD37A50B983C5E7C90AE93B";
  static const uint8_t binary_fingerprint[16]; // = {0x99,0x91,0x4B,0x93,0x2B,0xD3,0x7A,0x50,0xB9,0x83,0xC5,0xE7,0xC9,0x0A,0xE9,0x3B};


  virtual ~VideoSfM_finalize_presult() throw();

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);

};

class VideoSfMClient : virtual public VideoSfMIf {
 public:
  VideoSfMClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
    setProtocol(prot);
  }
  VideoSfMClient(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    setProtocol(iprot,oprot);
  }
 private:
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> prot) {
  setProtocol(prot,prot);
  }
  void setProtocol(boost::shared_ptr< ::apache::thrift::protocol::TProtocol> iprot, boost::shared_ptr< ::apache::thrift::protocol::TProtocol> oprot) {
    piprot_=iprot;
    poprot_=oprot;
    iprot_ = iprot.get();
    oprot_ = oprot.get();
  }
 public:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getInputProtocol() {
    return piprot_;
  }
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> getOutputProtocol() {
    return poprot_;
  }
  void authenticate(std::string& _return);
  void send_authenticate();
  void recv_authenticate(std::string& _return);
  int32_t newSession(const std::string& authToken, const std::vector<double> & camera);
  void send_newSession(const std::string& authToken, const std::vector<double> & camera);
  int32_t recv_newSession();
  int32_t cloneSession(const std::string& authToken, const int32_t oldSessionKey);
  void send_cloneSession(const std::string& authToken, const int32_t oldSessionKey);
  int32_t recv_cloneSession();
  int32_t newRsSession(const std::string& authToken, const std::vector<double> & camera, const RollingShutter::type rs, const std::vector<int32_t> & scanlines);
  void send_newRsSession(const std::string& authToken, const std::vector<double> & camera, const RollingShutter::type rs, const std::vector<int32_t> & scanlines);
  int32_t recv_newRsSession();
  int32_t newFrame(const std::string& authToken, const int32_t sessionKey, const Frame& frame);
  void send_newFrame(const std::string& authToken, const int32_t sessionKey, const Frame& frame);
  int32_t recv_newFrame();
  void getFrame(Frame& _return, const std::string& authToken, const int32_t sessionKey, const int32_t frameKey);
  void send_getFrame(const std::string& authToken, const int32_t sessionKey, const int32_t frameKey);
  void recv_getFrame(Frame& _return);
  int32_t newTrack(const std::string& authToken, const int32_t sessionKey, const Track& track);
  void send_newTrack(const std::string& authToken, const int32_t sessionKey, const Track& track);
  int32_t recv_newTrack();
  void getTracks(std::vector<Track> & _return, const std::string& authToken, const int32_t sessionKey);
  void send_getTracks(const std::string& authToken, const int32_t sessionKey);
  void recv_getTracks(std::vector<Track> & _return);
  void initialize(const std::string& authToken, const int32_t sessionKey);
  void send_initialize(const std::string& authToken, const int32_t sessionKey);
  void recv_initialize();
  bool fullBA(const std::string& authToken, const int32_t sessionKey, const int32_t maxIter, const bool reproject);
  void send_fullBA(const std::string& authToken, const int32_t sessionKey, const int32_t maxIter, const bool reproject);
  bool recv_fullBA();
  bool windowedBA(const std::string& authToken, const int32_t sessionKey, const int32_t startFrame, const int32_t endFrame, const int32_t maxIter, const bool reproject);
  void send_windowedBA(const std::string& authToken, const int32_t sessionKey, const int32_t startFrame, const int32_t endFrame, const int32_t maxIter, const bool reproject);
  bool recv_windowedBA();
  void finalize(const std::string& authToken, const int32_t sessionKey);
  void send_finalize(const std::string& authToken, const int32_t sessionKey);
  void recv_finalize();
 protected:
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> piprot_;
  boost::shared_ptr< ::apache::thrift::protocol::TProtocol> poprot_;
  ::apache::thrift::protocol::TProtocol* iprot_;
  ::apache::thrift::protocol::TProtocol* oprot_;
};

class VideoSfMProcessor : public ::apache::thrift::TDispatchProcessor {
 protected:
  boost::shared_ptr<VideoSfMIf> iface_;
  virtual bool dispatchCall(::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, const std::string& fname, int32_t seqid, void* callContext);
 private:
  typedef  void (VideoSfMProcessor::*ProcessFunction)(int32_t, ::apache::thrift::protocol::TProtocol*, ::apache::thrift::protocol::TProtocol*, void*);
  typedef std::map<std::string, ProcessFunction> ProcessMap;
  ProcessMap processMap_;
  void process_authenticate(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_newSession(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_cloneSession(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_newRsSession(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_newFrame(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getFrame(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_newTrack(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_getTracks(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_initialize(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_fullBA(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_windowedBA(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
  void process_finalize(int32_t seqid, ::apache::thrift::protocol::TProtocol* iprot, ::apache::thrift::protocol::TProtocol* oprot, void* callContext);
 public:
  VideoSfMProcessor(boost::shared_ptr<VideoSfMIf> iface) :
    iface_(iface) {
    processMap_["authenticate"] = &VideoSfMProcessor::process_authenticate;
    processMap_["newSession"] = &VideoSfMProcessor::process_newSession;
    processMap_["cloneSession"] = &VideoSfMProcessor::process_cloneSession;
    processMap_["newRsSession"] = &VideoSfMProcessor::process_newRsSession;
    processMap_["newFrame"] = &VideoSfMProcessor::process_newFrame;
    processMap_["getFrame"] = &VideoSfMProcessor::process_getFrame;
    processMap_["newTrack"] = &VideoSfMProcessor::process_newTrack;
    processMap_["getTracks"] = &VideoSfMProcessor::process_getTracks;
    processMap_["initialize"] = &VideoSfMProcessor::process_initialize;
    processMap_["fullBA"] = &VideoSfMProcessor::process_fullBA;
    processMap_["windowedBA"] = &VideoSfMProcessor::process_windowedBA;
    processMap_["finalize"] = &VideoSfMProcessor::process_finalize;
  }

  virtual ~VideoSfMProcessor() {}
};

class VideoSfMProcessorFactory : public ::apache::thrift::TProcessorFactory {
 public:
  VideoSfMProcessorFactory(const ::boost::shared_ptr< VideoSfMIfFactory >& handlerFactory) :
      handlerFactory_(handlerFactory) {}

  ::boost::shared_ptr< ::apache::thrift::TProcessor > getProcessor(const ::apache::thrift::TConnectionInfo& connInfo);

 protected:
  ::boost::shared_ptr< VideoSfMIfFactory > handlerFactory_;
};

class VideoSfMMultiface : virtual public VideoSfMIf {
 public:
  VideoSfMMultiface(std::vector<boost::shared_ptr<VideoSfMIf> >& ifaces) : ifaces_(ifaces) {
  }
  virtual ~VideoSfMMultiface() {}
 protected:
  std::vector<boost::shared_ptr<VideoSfMIf> > ifaces_;
  VideoSfMMultiface() {}
  void add(boost::shared_ptr<VideoSfMIf> iface) {
    ifaces_.push_back(iface);
  }
 public:
  void authenticate(std::string& _return) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->authenticate(_return);
    }
    ifaces_[i]->authenticate(_return);
    return;
  }

  int32_t newSession(const std::string& authToken, const std::vector<double> & camera) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->newSession(authToken, camera);
    }
    return ifaces_[i]->newSession(authToken, camera);
  }

  int32_t cloneSession(const std::string& authToken, const int32_t oldSessionKey) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->cloneSession(authToken, oldSessionKey);
    }
    return ifaces_[i]->cloneSession(authToken, oldSessionKey);
  }

  int32_t newRsSession(const std::string& authToken, const std::vector<double> & camera, const RollingShutter::type rs, const std::vector<int32_t> & scanlines) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->newRsSession(authToken, camera, rs, scanlines);
    }
    return ifaces_[i]->newRsSession(authToken, camera, rs, scanlines);
  }

  int32_t newFrame(const std::string& authToken, const int32_t sessionKey, const Frame& frame) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->newFrame(authToken, sessionKey, frame);
    }
    return ifaces_[i]->newFrame(authToken, sessionKey, frame);
  }

  void getFrame(Frame& _return, const std::string& authToken, const int32_t sessionKey, const int32_t frameKey) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getFrame(_return, authToken, sessionKey, frameKey);
    }
    ifaces_[i]->getFrame(_return, authToken, sessionKey, frameKey);
    return;
  }

  int32_t newTrack(const std::string& authToken, const int32_t sessionKey, const Track& track) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->newTrack(authToken, sessionKey, track);
    }
    return ifaces_[i]->newTrack(authToken, sessionKey, track);
  }

  void getTracks(std::vector<Track> & _return, const std::string& authToken, const int32_t sessionKey) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->getTracks(_return, authToken, sessionKey);
    }
    ifaces_[i]->getTracks(_return, authToken, sessionKey);
    return;
  }

  void initialize(const std::string& authToken, const int32_t sessionKey) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->initialize(authToken, sessionKey);
    }
    ifaces_[i]->initialize(authToken, sessionKey);
  }

  bool fullBA(const std::string& authToken, const int32_t sessionKey, const int32_t maxIter, const bool reproject) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->fullBA(authToken, sessionKey, maxIter, reproject);
    }
    return ifaces_[i]->fullBA(authToken, sessionKey, maxIter, reproject);
  }

  bool windowedBA(const std::string& authToken, const int32_t sessionKey, const int32_t startFrame, const int32_t endFrame, const int32_t maxIter, const bool reproject) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->windowedBA(authToken, sessionKey, startFrame, endFrame, maxIter, reproject);
    }
    return ifaces_[i]->windowedBA(authToken, sessionKey, startFrame, endFrame, maxIter, reproject);
  }

  void finalize(const std::string& authToken, const int32_t sessionKey) {
    size_t sz = ifaces_.size();
    size_t i = 0;
    for (; i < (sz - 1); ++i) {
      ifaces_[i]->finalize(authToken, sessionKey);
    }
    ifaces_[i]->finalize(authToken, sessionKey);
  }

};

}}} // namespace

#endif
