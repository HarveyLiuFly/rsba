/**
 * Autogenerated by Thrift Compiler (1.0.0-dev)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef sfm_TYPES_H
#define sfm_TYPES_H

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace vision { namespace sfm { namespace gen {

struct RollingShutter {
  enum type {
    HORIZONTAL = 1,
    VERTICAL = 2
  };
};

extern const std::map<int, const char*> _RollingShutter_VALUES_TO_NAMES;

class Observation;

class Track;

class ObservationRef;

class Frame;

class Session;

typedef struct _Observation__isset {
  _Observation__isset() : x(false), y(false), descriptor(false), color(false), matches(false), track(false) {}
  bool x;
  bool y;
  bool descriptor;
  bool color;
  bool matches;
  bool track;
} _Observation__isset;

class Observation {
 public:

  static const char* ascii_fingerprint; // = "4C91E08C4857B73EE7F1ECC3CC81100C";
  static const uint8_t binary_fingerprint[16]; // = {0x4C,0x91,0xE0,0x8C,0x48,0x57,0xB7,0x3E,0xE7,0xF1,0xEC,0xC3,0xCC,0x81,0x10,0x0C};

  Observation(const Observation&);
  Observation& operator=(const Observation&);
  Observation() : x(0), y(0), descriptor(), color(), track(0) {
  }

  virtual ~Observation() throw();
  double x;
  double y;
  std::string descriptor;
  std::string color;
  std::vector<ObservationRef>  matches;
  int32_t track;

  _Observation__isset __isset;

  void __set_x(const double val);

  void __set_y(const double val);

  void __set_descriptor(const std::string& val);

  void __set_color(const std::string& val);

  void __set_matches(const std::vector<ObservationRef> & val);

  void __set_track(const int32_t val);

  bool operator == (const Observation & rhs) const
  {
    if (!(x == rhs.x))
      return false;
    if (!(y == rhs.y))
      return false;
    if (__isset.descriptor != rhs.__isset.descriptor)
      return false;
    else if (__isset.descriptor && !(descriptor == rhs.descriptor))
      return false;
    if (__isset.color != rhs.__isset.color)
      return false;
    else if (__isset.color && !(color == rhs.color))
      return false;
    if (__isset.matches != rhs.__isset.matches)
      return false;
    else if (__isset.matches && !(matches == rhs.matches))
      return false;
    if (__isset.track != rhs.__isset.track)
      return false;
    else if (__isset.track && !(track == rhs.track))
      return false;
    return true;
  }
  bool operator != (const Observation &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Observation & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Observation &a, Observation &b);

typedef struct _Track__isset {
  _Track__isset() : obs(false), pt(false), color(false), valid(true) {}
  bool obs;
  bool pt;
  bool color;
  bool valid;
} _Track__isset;

class Track {
 public:

  static const char* ascii_fingerprint; // = "8E1A8FF7A6882F8EA901D7B82724E206";
  static const uint8_t binary_fingerprint[16]; // = {0x8E,0x1A,0x8F,0xF7,0xA6,0x88,0x2F,0x8E,0xA9,0x01,0xD7,0xB8,0x27,0x24,0xE2,0x06};

  Track(const Track&);
  Track& operator=(const Track&);
  Track() : color(), valid(false) {
  }

  virtual ~Track() throw();
  std::vector<ObservationRef>  obs;
  std::vector<double>  pt;
  std::string color;
  bool valid;

  _Track__isset __isset;

  void __set_obs(const std::vector<ObservationRef> & val);

  void __set_pt(const std::vector<double> & val);

  void __set_color(const std::string& val);

  void __set_valid(const bool val);

  bool operator == (const Track & rhs) const
  {
    if (!(obs == rhs.obs))
      return false;
    if (__isset.pt != rhs.__isset.pt)
      return false;
    else if (__isset.pt && !(pt == rhs.pt))
      return false;
    if (__isset.color != rhs.__isset.color)
      return false;
    else if (__isset.color && !(color == rhs.color))
      return false;
    if (!(valid == rhs.valid))
      return false;
    return true;
  }
  bool operator != (const Track &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Track & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Track &a, Track &b);

typedef struct _ObservationRef__isset {
  _ObservationRef__isset() : frame(false), obs(false), valid(true) {}
  bool frame;
  bool obs;
  bool valid;
} _ObservationRef__isset;

class ObservationRef {
 public:

  static const char* ascii_fingerprint; // = "E0991C843E3F9D01A30FF59D9FBC2CAF";
  static const uint8_t binary_fingerprint[16]; // = {0xE0,0x99,0x1C,0x84,0x3E,0x3F,0x9D,0x01,0xA3,0x0F,0xF5,0x9D,0x9F,0xBC,0x2C,0xAF};

  ObservationRef(const ObservationRef&);
  ObservationRef& operator=(const ObservationRef&);
  ObservationRef() : frame(0), obs(0), valid(false) {
  }

  virtual ~ObservationRef() throw();
  int32_t frame;
  int32_t obs;
  bool valid;

  _ObservationRef__isset __isset;

  void __set_frame(const int32_t val);

  void __set_obs(const int32_t val);

  void __set_valid(const bool val);

  bool operator == (const ObservationRef & rhs) const
  {
    if (!(frame == rhs.frame))
      return false;
    if (!(obs == rhs.obs))
      return false;
    if (!(valid == rhs.valid))
      return false;
    return true;
  }
  bool operator != (const ObservationRef &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ObservationRef & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(ObservationRef &a, ObservationRef &b);

typedef struct _Frame__isset {
  _Frame__isset() : obs(false), poses(false), cam(false), priorPoses(false) {}
  bool obs;
  bool poses;
  bool cam;
  bool priorPoses;
} _Frame__isset;

class Frame {
 public:

  static const char* ascii_fingerprint; // = "D5B2E16AA40BCE0792C11534EDEB37F0";
  static const uint8_t binary_fingerprint[16]; // = {0xD5,0xB2,0xE1,0x6A,0xA4,0x0B,0xCE,0x07,0x92,0xC1,0x15,0x34,0xED,0xEB,0x37,0xF0};

  Frame(const Frame&);
  Frame& operator=(const Frame&);
  Frame() {
  }

  virtual ~Frame() throw();
  std::vector<Observation>  obs;
  std::vector<std::vector<double> >  poses;
  std::vector<double>  cam;
  std::vector<std::vector<double> >  priorPoses;

  _Frame__isset __isset;

  void __set_obs(const std::vector<Observation> & val);

  void __set_poses(const std::vector<std::vector<double> > & val);

  void __set_cam(const std::vector<double> & val);

  void __set_priorPoses(const std::vector<std::vector<double> > & val);

  bool operator == (const Frame & rhs) const
  {
    if (!(obs == rhs.obs))
      return false;
    if (__isset.poses != rhs.__isset.poses)
      return false;
    else if (__isset.poses && !(poses == rhs.poses))
      return false;
    if (__isset.cam != rhs.__isset.cam)
      return false;
    else if (__isset.cam && !(cam == rhs.cam))
      return false;
    if (__isset.priorPoses != rhs.__isset.priorPoses)
      return false;
    else if (__isset.priorPoses && !(priorPoses == rhs.priorPoses))
      return false;
    return true;
  }
  bool operator != (const Frame &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Frame & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Frame &a, Frame &b);

typedef struct _Session__isset {
  _Session__isset() : cam(false), frames(false), tracks(false), rs(false), scanlines(false), width(false), height(false) {}
  bool cam;
  bool frames;
  bool tracks;
  bool rs;
  bool scanlines;
  bool width;
  bool height;
} _Session__isset;

class Session {
 public:

  static const char* ascii_fingerprint; // = "22BD041447F22376C16EEFD95439F80E";
  static const uint8_t binary_fingerprint[16]; // = {0x22,0xBD,0x04,0x14,0x47,0xF2,0x23,0x76,0xC1,0x6E,0xEF,0xD9,0x54,0x39,0xF8,0x0E};

  Session(const Session&);
  Session& operator=(const Session&);
  Session() : rs((RollingShutter::type)0), width(0), height(0) {
  }

  virtual ~Session() throw();
  std::vector<double>  cam;
  std::vector<Frame>  frames;
  std::vector<Track>  tracks;
  RollingShutter::type rs;
  std::vector<int32_t>  scanlines;
  int32_t width;
  int32_t height;

  _Session__isset __isset;

  void __set_cam(const std::vector<double> & val);

  void __set_frames(const std::vector<Frame> & val);

  void __set_tracks(const std::vector<Track> & val);

  void __set_rs(const RollingShutter::type val);

  void __set_scanlines(const std::vector<int32_t> & val);

  void __set_width(const int32_t val);

  void __set_height(const int32_t val);

  bool operator == (const Session & rhs) const
  {
    if (!(cam == rhs.cam))
      return false;
    if (!(frames == rhs.frames))
      return false;
    if (!(tracks == rhs.tracks))
      return false;
    if (__isset.rs != rhs.__isset.rs)
      return false;
    else if (__isset.rs && !(rs == rhs.rs))
      return false;
    if (__isset.scanlines != rhs.__isset.scanlines)
      return false;
    else if (__isset.scanlines && !(scanlines == rhs.scanlines))
      return false;
    if (!(width == rhs.width))
      return false;
    if (!(height == rhs.height))
      return false;
    return true;
  }
  bool operator != (const Session &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Session & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

};

void swap(Session &a, Session &b);

}}} // namespace

#endif
